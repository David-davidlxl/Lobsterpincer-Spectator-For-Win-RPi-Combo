"""This module is responsible for evaluating board positions and generating related outputs."""


import chess
import chess.engine


def initialize_engine() -> chess.engine.SimpleEngine:
    """Initialize the Stockfish engine."""
    try:
        engine = chess.engine.SimpleEngine.popen_uci(
            "Stockfish/stockfish-windows-2022-x86-64-avx2.exe"
        )
    except (
        FileNotFoundError
    ):  # This happens when we run this file from the "lpspectator" directory in the terminal
        engine = chess.engine.SimpleEngine.popen_uci(
            "../Stockfish/stockfish-windows-2022-x86-64-avx2.exe"
        )
    return engine


def generate_engine_output(
    engine: chess.engine.SimpleEngine, board: chess.Board, print_in_terminal: bool
) -> list:
    """Generate the engine output.

    This function returns the top two moves (in short algebraic notation)
    generated by Stockfish at depth 17 along with their corresponding
    floating-point (or f"#{some_integer}" in the case of checkmate) evaluations.

    :param engine: Chess engine to be used.

    :param board: Current board position to be evaluated.

    :return: Length-4 list containing the top two moves and their evaluations
        (if only one legal move exists, the last two elements will be `None`).
    """
    info = engine.analyse(board, chess.engine.Limit(depth=17), multipv=2)

    best_move = board.san(info[0]["pv"][0])
    if info[0]["score"].white().score() is not None:
        best_move_eval = info[0]["score"].white().score() / 100
        best_move_eval = f"{best_move_eval}"
    else:
        best_move_eval = info[0]["score"].white().mate()
        best_move_eval = f"#{best_move_eval}"

    if len(info) == 1:
        second_best_move = second_best_move_eval = None
        if print_in_terminal:
            print(f"\t(only_move, only_move_eval) = ({best_move}, {best_move_eval})")
    else:
        second_best_move = board.san(info[1]["pv"][0])
        if not info[1]["score"].white().score() is None:
            second_best_move_eval = info[1]["score"].white().score() / 100
            second_best_move_eval = f"{second_best_move_eval}"
        else:
            second_best_move_eval = info[1]["score"].white().mate()
            second_best_move_eval = f"#{second_best_move_eval}"

        if print_in_terminal:
            print(
                f"\t(best_move, best_move_eval, second_best_move, second_best_move_eval) = ({best_move}, {best_move_eval}, {second_best_move}, {second_best_move_eval})"
            )
    engine_output = [best_move, best_move_eval, second_best_move, second_best_move_eval]
    return engine_output


def is_critical_moment(engine_output: list) -> bool:
    """Determine if the chess position is a critical one.

    :param engine_output: Top two moves in the current position along with their evaluations.

    :return: Boolean variable indicating whether it is a critical moment.
    """
    assert engine_output[2] is not None and engine_output[3] is not None
    best_move_eval, second_best_move_eval = engine_output[1], engine_output[3]
    if not "#" in best_move_eval and not "#" in second_best_move_eval:
        best_move_eval = float(best_move_eval)
        second_best_move_eval = float(second_best_move_eval)
        if (
            abs(best_move_eval - second_best_move_eval) >= 2
        ):  # There is a at-least-2-point advantage difference between best move and second best move
            if best_move_eval - second_best_move_eval > 0:  # white to play
                if (
                    second_best_move_eval <= 2
                ):  # White would not be winning if they could not find the best move
                    is_critical_moment = True
                else:  # There is more than one winning move for white
                    is_critical_moment = False
            else:  # It's black to play
                if (
                    second_best_move_eval >= -2
                ):  # Black would not be winning if they could not find the best move
                    is_critical_moment = True
                else:  # There is more than one winning move for black
                    is_critical_moment = False
        else:
            is_critical_moment = False
    elif (
        "#" in best_move_eval and not "#" in second_best_move_eval
    ):  # There is only one move to force checkmate for white
        is_critical_moment = True
    elif (
        "#-" in best_move_eval and not "#-" in second_best_move_eval
    ):  # There is only one move to force checkmate for black
        is_critical_moment = True
    else:  # There is more than one move to checkmate
        is_critical_moment = False

    return is_critical_moment


def num_of_lights_to_turn_on(engine_output: list) -> int:
    """Determine the number of LED lights to turn on.

    :param engine_output: Top two moves in the current position along with their evaluations.

    :return: Number of LED lights to turn on.
    """
    best_move_eval = engine_output[1]
    if "#-" in best_move_eval:  # There is a forced checkmate against white
        num_of_lights = 0
    elif "#" in best_move_eval:  # There is a forced checkmate against black
        num_of_lights = 8
    else:
        best_move_eval = float(best_move_eval)
        if (
            best_move_eval >= -0.5 and best_move_eval <= 0.5
        ):  # This is a balanced position
            num_of_lights = 4
        elif (
            best_move_eval >= -1.5 and best_move_eval < -0.5
        ):  # There is a 1-point advantage for black
            num_of_lights = 3
        elif (
            best_move_eval <= 1.5 and best_move_eval > 0.5
        ):  # There is a 1-point advantage for whtie
            num_of_lights = 5
        elif (
            best_move_eval >= -2.5 and best_move_eval < -1.5
        ):  # There is a 2-point advantage for black
            num_of_lights = 2
        elif (
            best_move_eval <= 2.5 and best_move_eval > 1.5
        ):  # There is a 2-point advantage for white
            num_of_lights = 6
        elif (
            best_move_eval >= -3.5 and best_move_eval < -2.5
        ):  # There is a 3-point advantage for black
            num_of_lights = 1
        elif (
            best_move_eval <= 3.5 and best_move_eval > 2.5
        ):  # There is a 3-point advantage for white
            num_of_lights = 7
        elif best_move_eval < -3.5:
            num_of_lights = 0
        elif best_move_eval > 3.5:
            num_of_lights = 8

    return num_of_lights


def detect_harry(
    detected_move: chess.Move, engine_output: list, board: chess.Board
) -> bool:
    """Detect Harry the h-pawn.

    This function detects whether Harry the h-pawn is moving up the board
    into the opponent's territory (but not promoting) while not making the
    position losing.

    :param detected_move: Last move that the player just played.

    :param engine_output: Top two moves in the current position along with their evaluations.

    :param board: Current board position.

    :return: Boolean variable indicating the presence of an aggressive, not-losing push of an h-pawn.
    """
    assert len(board.move_stack) >= 1

    board.pop()
    detected_move_san = board.san(detected_move)
    board.push(detected_move)

    white_harry_moves = ["h5", "h6", "h7"]
    black_harry_moves = ["h4", "h3", "h2"]

    if (
        board.turn == chess.BLACK and detected_move_san in white_harry_moves
    ):  # White just pushed the h-pawn to h5, h6, or h7
        if "#-" in engine_output[1]:  # White is getting checkmated
            output = False
        elif "#" in engine_output[1]:  # Black is getting checkmated
            output = True
        elif float(engine_output[1]) >= -2:  # White is not losing
            output = True
        else:
            output = False

    elif (
        board.turn == chess.WHITE and detected_move_san in black_harry_moves
    ):  # Black just pushed the h-pawn to h4, h3, or h2
        if "#-" in engine_output[1]:  # White is getting checkmated
            output = True
        elif "#" in engine_output[1]:  # Black is getting checkmated
            output = False
        if float(engine_output[1]) <= 2:  # Black is not losing
            output = True
        else:
            output = False
    else:  # The last move played was not a "pushing Harry into opponent's territory" move
        output = False
    return output


def detect_lobsterpincer(board: chess.Board) -> bool:
    """Detect whether the Lobster Pincer mate is in the current position.

    This function detects whether the Lobster Pincer mate (which is a generalization
    of the "Lolli's mate") is in the current position.

    :param board: Current board position.

    :return: Boolean indicating the presence of the Lobster Pincer mate.
    """
    assert board.is_checkmate()

    if (
        (
            (
                board.piece_type_at(chess.G8) == chess.KING
                and board.color_at(chess.G8) == chess.BLACK
            )
            or (
                board.piece_type_at(chess.H8) == chess.KING
                and board.color_at(chess.H8) == chess.BLACK
            )
        )
        and board.piece_type_at(chess.F7) == chess.PAWN
        and board.color_at(chess.F7) == chess.BLACK
        and board.piece_type_at(chess.G7) == chess.QUEEN
        and board.color_at(chess.G7) == chess.WHITE
        and (
            (
                board.piece_type_at(chess.F6) == chess.PAWN
                or board.piece_type_at(chess.F6) == chess.BISHOP
            )
            and board.color_at(chess.F6) == chess.WHITE
        )
        or (
            (
                board.piece_type_at(chess.H6) == chess.PAWN
                or board.piece_type_at(chess.H6) == chess.BISHOP
            )
            and board.color_at(chess.H6) == chess.WHITE
        )
    ):  # This is case 1 (top-right corner)
        return True
    elif (
        (
            (
                board.piece_type_at(chess.B8) == chess.KING
                and board.color_at(chess.B8) == chess.BLACK
            )
            or (
                board.piece_type_at(chess.A8) == chess.KING
                and board.color_at(chess.A8) == chess.BLACK
            )
        )
        and board.piece_type_at(chess.C7) == chess.PAWN
        and board.color_at(chess.C7) == chess.BLACK
        and board.piece_type_at(chess.B7) == chess.QUEEN
        and board.color_at(chess.B7) == chess.WHITE
        and (
            (
                board.piece_type_at(chess.C6) == chess.PAWN
                or board.piece_type_at(chess.C6) == chess.BISHOP
            )
            and board.color_at(chess.C6) == chess.WHITE
        )
        or (
            (
                board.piece_type_at(chess.A6) == chess.PAWN
                or board.piece_type_at(chess.A6) == chess.BISHOP
            )
            and board.color_at(chess.A6) == chess.WHITE
        )
    ):  # This is case 2 (top-left corner)
        return True
    elif (
        (
            (
                board.piece_type_at(chess.B1) == chess.KING
                and board.color_at(chess.B1) == chess.WHITE
            )
            or (
                board.piece_type_at(chess.A1) == chess.KING
                and board.color_at(chess.A1) == chess.WHITE
            )
        )
        and board.piece_type_at(chess.C2) == chess.PAWN
        and board.color_at(chess.C2) == chess.WHITE
        and board.piece_type_at(chess.B2) == chess.QUEEN
        and board.color_at(chess.B2) == chess.BLACK
        and (
            (
                board.piece_type_at(chess.C3) == chess.PAWN
                or board.piece_type_at(chess.C3) == chess.BISHOP
            )
            and board.color_at(chess.C3) == chess.BLACK
        )
        or (
            (
                board.piece_type_at(chess.A3) == chess.PAWN
                or board.piece_type_at(chess.A3) == chess.BISHOP
            )
            and board.color_at(chess.A3) == chess.BLACK
        )
    ):  # This is case 3 (bottom-left corner)
        return True
    elif (
        (
            (
                board.piece_type_at(chess.G1) == chess.KING
                and board.color_at(chess.G1) == chess.WHITE
            )
            or (
                board.piece_type_at(chess.H1) == chess.KING
                and board.color_at(chess.H1) == chess.WHITE
            )
        )
        and board.piece_type_at(chess.F2) == chess.PAWN
        and board.color_at(chess.F2) == chess.WHITE
        and board.piece_type_at(chess.G2) == chess.QUEEN
        and board.color_at(chess.G2) == chess.BLACK
        and (
            (
                board.piece_type_at(chess.F3) == chess.PAWN
                or board.piece_type_at(chess.F3) == chess.BISHOP
            )
            and board.color_at(chess.F3) == chess.BLACK
        )
        or (
            (
                board.piece_type_at(chess.H3) == chess.PAWN
                or board.piece_type_at(chess.H3) == chess.BISHOP
            )
            and board.color_at(chess.H3) == chess.BLACK
        )
    ):  # This is case 4 (bottom-right corner)
        return True
    else:
        return False


def quit_engine(engine: chess.engine.SimpleEngine):
    """Quit the chess engine."""
    engine.quit()


if __name__ == "__main__":
    import time

    engine = initialize_engine()

    # board = chess.Board()
    board = chess.Board(
        "r1bqkb1r/pp1npQpp/5n2/2pp4/3PP3/2N5/PPP2PPP/R1B1KBNR b KQkq - 0 5"
    )

    detected_move = chess.Move.from_uci("e8f7")

    start_time = time.time()
    engine_output = generate_engine_output(engine, board, print_in_terminal=True)
    finish_time = time.time()
    print(f"\tThis evaluation took {finish_time - start_time} s")

    quit_engine(engine)
